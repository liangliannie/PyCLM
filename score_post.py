# from ILAMB import Postimport numpy as npimport matplotlib.cm as cmimport matplotlib.pyplot as pltimport seaborn as snimport pandas as pdimport matplotlib as mplimport osfontsize = 20def RegisterCustomColormaps():    """Adds the 'stoplight' and 'RdGn' colormaps to matplotlib's database    from ILAMB Post    """    import colorsys as cs    # stoplight colormap    Rd1 = [1., 0., 0.];    Rd2 = Rd1    Yl1 = [1., 1., 0.];    Yl2 = Yl1    Gn1 = [0., 1., 0.];    Gn2 = Gn1    val = 0.65    Rd1 = cs.rgb_to_hsv(Rd1[0], Rd1[1], Rd1[2])    Rd1 = cs.hsv_to_rgb(Rd1[0], Rd1[1], val)    Yl1 = cs.rgb_to_hsv(Yl1[0], Yl1[1], Yl1[2])    Yl1 = cs.hsv_to_rgb(Yl1[0], Yl1[1], val)    Gn1 = cs.rgb_to_hsv(Gn1[0], Gn1[1], Gn1[2])    Gn1 = cs.hsv_to_rgb(Gn1[0], Gn1[1], val)    p = 0    level1 = 0.5    level2 = 0.75    RdYlGn = {'red': ((0.0, 0.0, Rd1[0]),                      (level1 - p, Rd2[0], Rd2[0]),                      (level1 + p, Yl1[0], Yl1[0]),                      (level2 - p, Yl2[0], Yl2[0]),                      (level2 + p, Gn1[0], Gn1[0]),                      (1.00, Gn2[0], 0.0)),              'green': ((0.0, 0.0, Rd1[1]),                        (level1 - p, Rd2[1], Rd2[1]),                        (level1 + p, Yl1[1], Yl1[1]),                        (level2 - p, Yl2[1], Yl2[1]),                        (level2 + p, Gn1[1], Gn1[1]),                        (1.00, Gn2[1], 0.0)),              'blue': ((0.0, 0.0, Rd1[2]),                       (level1 - p, Rd2[2], Rd2[2]),                       (level1 + p, Yl1[2], Yl1[2]),                       (level2 - p, Yl2[2], Yl2[2]),                       (level2 + p, Gn1[2], Gn1[2]),                       (1.00, Gn2[2], 0.0))}    plt.register_cmap(name='stoplight', data=RdYlGn)    # RdGn colormap    val = 0.8    Rd = cs.rgb_to_hsv(1, 0, 0)    Rd = cs.hsv_to_rgb(Rd[0], Rd[1], val)    Gn = cs.rgb_to_hsv(0, 1, 0)    Gn = cs.hsv_to_rgb(Gn[0], Gn[1], val)    RdGn = {'red': ((0.0, 0.0, Rd[0]),                    (0.5, 1.0, 1.0),                    (1.0, Gn[0], 0.0)),            'green': ((0.0, 0.0, Rd[1]),                      (0.5, 1.0, 1.0),                      (1.0, Gn[1], 0.0)),            'blue': ((0.0, 0.0, Rd[2]),                     (0.5, 1.0, 1.0),                     (1.0, Gn[2], 0.0))}    plt.register_cmap(name='RdGn', data=RdGn)def BenchmarkSummaryFigure(models, variables, data, figname, vcolor=None):    """Creates a summary figure for the benchmark results contained in the    data array. from ILAMB    Parameters    ----------    models : list        a list of the model names    variables : list        a list of the variable names    data : numpy.ndarray or numpy.ma.ndarray        data scores whose shape is ( len(variables), len(models) )    figname : str        the full path of the output file to write    vcolor : list, optional        an array parallel to the variables array containing background        colors for the labels to be displayed on the y-axis.    """    from mpl_toolkits.axes_grid1 import make_axes_locatable    # data checks    assert type(models) is type(list())    assert type(variables) is type(list())    assert (type(data) is type(np.empty(1)) or            type(data) is type(np.ma.empty(1)))    assert data.shape[0] == len(variables)    assert data.shape[1] == len(models)    assert type(figname) is type("")    if vcolor is not None:        assert type(vcolor) is type(list())        assert len(vcolor) == len(variables)    # define some parameters    nmodels = len(models)    nvariables = len(variables)    w = max((nmodels - 3.) / (14. - 3.) * (9.5 - 5.08) + 5.08, 7.)  # heuristic for figure size    h = 8.    bad = 0.5    if "stoplight" not in plt.colormaps(): RegisterCustomColormaps()    # plot the variable scores    fig, ax = plt.subplots(figsize=(w, h), ncols=2, tight_layout=True)    cmap = plt.get_cmap('stoplight')    cmap.set_bad('k', bad)    qc = ax[0].pcolormesh(np.ma.masked_invalid(data[::-1, :]), cmap=cmap, vmin=0, vmax=1, linewidth=0)    div = make_axes_locatable(ax[0])    fig.colorbar(qc,                 ticks=(0, 0.25, 0.5, 0.75, 1.0),                 format="%g",                 cax=div.append_axes("bottom", size="5%", pad=0.05),                 orientation="horizontal",                 label="Variable Score")    plt.tick_params(which='both', length=0)    ax[0].xaxis.tick_top()    ax[0].set_xticks(np.arange(nmodels) + 0.5)    ax[0].set_xticklabels(models, rotation=90)    ax[0].set_yticks(np.arange(nvariables) + 0.5)    ax[0].set_yticklabels(variables[::-1])    ax[0].set_ylim(0, nvariables)    ax[0].tick_params('both', length=0, width=0, which='major')    ax[0].tick_params(axis='y', pad=10)    if vcolor is not None:        for i, t in enumerate(ax[0].yaxis.get_ticklabels()):            t.set_backgroundcolor(vcolor[::-1][i])    # compute and plot the variable z-scores    np.seterr(invalid='ignore', under='ignore')    data = np.ma.masked_invalid(data)    data.data[data.mask] = 1.    data = np.ma.masked_values(data, 1.)    mean = data.mean(axis=1)    std = data.std(axis=1)    np.seterr(invalid='ignore', under='ignore')    Z = (data - mean[:, np.newaxis]) / std[:, np.newaxis]    Z = np.ma.masked_invalid(Z)    np.seterr(invalid='warn', under='raise')    cmap = plt.get_cmap('RdGn')    cmap.set_bad('k', bad)    qc = ax[1].pcolormesh(Z[::-1], cmap=cmap, vmin=-2, vmax=2, linewidth=0)    div = make_axes_locatable(ax[1])    fig.colorbar(qc,                 ticks=(-2, -1, 0, 1, 2),                 format="%+d",                 cax=div.append_axes("bottom", size="5%", pad=0.05),                 orientation="horizontal",                 label="Variable Z-score")    plt.tick_params(which='both', length=0)    ax[1].xaxis.tick_top()    ax[1].set_xticks(np.arange(nmodels) + 0.5)    ax[1].set_xticklabels(models, rotation=90)    ax[1].tick_params('both', length=0, width=0, which='major')    ax[1].set_yticks([])    ax[1].set_ylim(0, nvariables)    # save figure    fig.savefig(figname)def calculate_scores(data1, data2, data3, data4, model1, model2, model3, model4):        # Reference dataset    import numpy as NP    refstd_un1 = data1.std(ddof=1)  # Reference standard deviation    refstd_un2 = data2.std(ddof=1)  # Reference standard deviation    refstd_un3 = data3.std(ddof=1)  # Reference standard deviation    refstd_un4 = data4.std(ddof=1)  # Reference standard deviation    normalize = True    # Models    # Compute stddev and correlation coefficient of models    if normalize:        # print([[m.std(ddof=1)/refstd_un, NP.ma.corrcoef(data, m)[0, 1]] for m in models])        samples1 = NP.array([[m.std(ddof=1) / refstd_un1, abs(NP.ma.corrcoef(data1, m)[0, 1])] for m in model1])        samples2 = NP.array([[m.std(ddof=1) / refstd_un2, abs(NP.ma.corrcoef(data2, m)[0, 1])] for m in model2])        samples3 = NP.array([[m.std(ddof=1) / refstd_un3, abs(NP.ma.corrcoef(data3, m)[0, 1])] for m in model3])        samples4 = NP.array([[m.std(ddof=1) / refstd_un4, abs(NP.ma.corrcoef(data4, m)[0, 1])] for m in model4])    return [samples1, samples2, samples3, samples4]def time_basic_score(samples):    [samples1, samples2, samples3, samples4] = samples    model_score = []    for i, (stddev, corrcoef) in enumerate(samples1):        model_score.append(corrcoef)  # /abs(stddev-1))    for i, (stddev, corrcoef) in enumerate(samples2):        model_score[i] += corrcoef  # /abs(stddev-1)    for i, (stddev, corrcoef) in enumerate(samples3):        model_score[i] += corrcoef  # / abs(stddev - 1)    for i, (stddev, corrcoef) in enumerate(samples4):        model_score[i] += corrcoef  # / abs(stddev - 1)        model_score[i] /= 4.0    return model_scoredef time_basic_score5(samples):    [samples1, samples2, samples3, samples4, samples5] = samples    model_score = []    for i, (stddev, corrcoef) in enumerate(samples1):        model_score.append(corrcoef)  # /abs(stddev-1))    for i, (stddev, corrcoef) in enumerate(samples2):        model_score[i] += corrcoef  # /abs(stddev-1)    for i, (stddev, corrcoef) in enumerate(samples3):        model_score[i] += corrcoef  # / abs(stddev - 1)    for i, (stddev, corrcoef) in enumerate(samples4):        model_score[i] += corrcoef  # / abs(stddev - 1)    for i, (stddev, corrcoef) in enumerate(samples5):        model_score[i] += corrcoef  # / abs(stddev - 1)        model_score[i] /= 5.0    return model_scoredef time_basic_score3(samples):    [samples1, samples2, samples3] = samples    model_score = []    for i, (stddev, corrcoef) in enumerate(samples1):        model_score.append(corrcoef)  # /abs(stddev-1))    for i, (stddev, corrcoef) in enumerate(samples2):        model_score[i] += corrcoef  # /abs(stddev-1)    for i, (stddev, corrcoef) in enumerate(samples3):        model_score[i] += corrcoef  # / abs(stddev - 1)        model_score[i] /= 3.0    return model_scoreclass score_system(object):    def __init__(self, mainfiledir, site_name, models_name, variable_list, variable_scores, repsonse_score):        self.filedir = mainfiledir        self.site_name = site_name        self.models_name = models_name        self.variable_list = variable_list        self.variable_scores = variable_scores # variable, scoretype, site, models        self.response_score = repsonse_score        # self.type_score = (variable_scores[:,0,:,:]+variable_scores[:,1,:,:]+variable_scores[:,2,:,:]+variable_scores[:,3,:,:]+variable_scores[:,4,:,:]+variable_scores[:,5,:,:]+variable_scores[:,6,:,:]+variable_scores[:,7,:,:])/9.0        self.type_score = (variable_scores[:,0,:,:]+variable_scores[:,0,:,:]+variable_scores[:,0,:,:]+variable_scores[:,0,:,:]+variable_scores[:,0,:,:]+variable_scores[:,0,:,:]+variable_scores[:,0,:,:]+variable_scores[:,0,:,:])/9.0    def plot_summary(self):        count = 0        for j, site in enumerate(self.site_name):            if self.site_name.mask[j]:                continue            print('Process score_' + site + '_No.' + str(j) + '!')            figname = self.filedir + 'score' + '/' + site + 'summary_score.png'            data = (self.type_score[:, count, :] + self.type_score[:, count, :]) # how to define this caculations???            # print(data123.shape,len(self.models_name), len(self.variable_list))            BenchmarkSummaryFigure(self.models_name, self.variable_list, data, figname)            plt.close('all')            count += 1    def plot_summary_all(self):        fig, axes = plt.subplots(len(self.models_name), len(self.site_name[~self.site_name.mask]), sharex=True, sharey=True, squeeze=False, figsize=(2*len(self.site_name),15))        fig.subplots_adjust(wspace=0.03, hspace=0.03)        color_vals = [-1, 0, 1]        # my_norm = mpl.colors.Normalize(-1, 1)  # maps your data to the range [0, 1]        # my_cmap = mpl.cm.get_cmap('RdBu', len(color_vals))  # can pick your color map        ax_cb = fig.add_axes([.91, .3, .03, .4])        count = 0        countcount = -1        for i in range(len(self.site_name)): # site            if self.site_name.mask[i]:                continue            for j in range(len(self.models_name)):# models                array = self.type_score[:, count, j]  ## Put n variables in each site                df_cm = pd.DataFrame(array)                name = [self.variable_list[ii] + '(' + str(array[ii])[:5] + ')' for ii in range(len(array))]                annot = np.array([name]).T                # ax.pie(array, autopct=lambda(p): '{v:d}'.format(p * sum(list(array)) / 100), startangle=90,colors=my_cmap(my_norm(color_vals)))                if any(array)<=1 and any(array)>=0:                    countcount += 1                sn.heatmap(df_cm, annot=annot, cmap='PuBuGn', cbar= countcount == 0, ax=axes[j][count],                           vmin=0, vmax=1, fmt='',                           cbar_ax=None if countcount!=0 else ax_cb, annot_kws={"size": 12})                if j == len(self.models_name)-1:                    axes[j][count].set_xlabel(self.site_name[i], fontsize=fontsize, rotation=45)                if count == 0:                    axes[j][count].set_ylabel(self.models_name[j], fontsize=fontsize)                # axes[i][j].axis('off')                axes[j][count].set_yticklabels([])                axes[j][count].set_xticklabels([])            count += 1        # plt.xticks(rotation=45)        fig.savefig(self.filedir + 'summary.png')    def plot_variable_score(self):        fig, axes = plt.subplots(len(self.site_name), len(self.models_name), sharex=True, sharey=True, figsize=(15,2*len(self.site_name)))        fig.subplots_adjust(wspace=0.03, hspace=0.03)        color_vals = [-1, 0, 1]        # my_norm = mpl.colors.Normalize(-1, 1)  # maps your data to the range [0, 1]        # my_cmap = mpl.cm.get_cmap('RdBu', len(color_vals))  # can pick your color map        ax_cb = fig.add_axes([.91, .3, .03, .4])        for j in range(len(self.models_name)): # models            for k in range(len(self.variable_list)):                array = self.type_score[k, :, j]  ## Put n sites in one picture                # array = [15, 30, 45, 10]                df_cm = pd.DataFrame(array)                # ax.pie(array, autopct=lambda(p): '{v:d}'.format(p * sum(list(array)) / 100), startangle=90,colors=my_cmap(my_norm(color_vals)))                sn.heatmap(df_cm, annot=True, cmap='PuBuGn', cbar=k == 0, ax=axes[k][j],                           vmin=0, vmax=1,                           cbar_ax=None if k else ax_cb)                # print(i, j)                if j == 0:                    axes[k][j].set_ylabel((self.site_name[k]))                if k == len(self.site_name) - 1:                    axes[k][j].set_xlabel(self.models_name[j])                # axes[i][j].axis('off')                axes[k][j].set_yticklabels([])                axes[k][j].set_xticklabels([])        fig.savefig(self.filedir + 'summary.png')    def plot_all(self):        directory = self.filedir + 'score' + '/'        if not os.path.exists(directory):            os.makedirs(directory)        self.plot_summary()        self.plot_summary_all()        # self.variable_scores()